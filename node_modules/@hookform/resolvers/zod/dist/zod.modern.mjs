import{validateFieldsNatively as e,toNestErrors as r}from"@hookform/resolvers";import{appendErrors as t}from"react-hook-form";function s(e,r,t){function s(t,s){var n;Object.defineProperty(t,"_zod",{value:t._zod??{},enumerable:!1}),(n=t._zod).traits??(n.traits=new Set),t._zod.traits.add(e),r(t,s);for(const e in a.prototype)e in t||Object.defineProperty(t,e,{value:a.prototype[e].bind(t)});t._zod.constr=a,t._zod.def=s}const n=t?.Parent??Object;class o extends n{}function a(e){var r;const n=t?.Parent?new o:this;s(n,e),(r=n._zod).deferred??(r.deferred=[]);for(const e of n._zod.deferred)e();return n}return Object.defineProperty(o,"name",{value:e}),Object.defineProperty(a,"init",{value:s}),Object.defineProperty(a,Symbol.hasInstance,{value:r=>!!(t?.Parent&&r instanceof t.Parent)||r?._zod?.traits?.has(e)}),Object.defineProperty(a,"name",{value:e}),a}class n extends Error{constructor(){super("Encountered Promise during synchronous parse. Use .parseAsync() instead.")}}const o={};function a(e){return e&&Object.assign(o,e),o}function i(e,r){return"bigint"==typeof r?r.toString():r}function c(e){return"string"==typeof e?e:e?.message}function u(e,r,t){const s={...e,path:e.path??[]};if(!e.message){const n=c(e.inst?._zod.def?.error?.(e))??c(r?.error?.(e))??c(t.customError?.(e))??c(t.localeError?.(e))??"Invalid input";s.message=n}return delete s.inst,delete s.continue,r?.reportInput||delete s.input,s}const d=(e,r)=>{e.name="$ZodError",Object.defineProperty(e,"_zod",{value:e._zod,enumerable:!1}),Object.defineProperty(e,"issues",{value:r,enumerable:!1}),Object.defineProperty(e,"message",{get:()=>JSON.stringify(r,i,2),enumerable:!0})},f=s("$ZodError",d),l=s("$ZodError",d,{Parent:Error}),p=/* @__PURE__*/(e=>(r,t,s,o)=>{const i=s?Object.assign(s,{async:!1}):{async:!1},c=r._zod.run({value:t,issues:[]},i);if(c instanceof Promise)throw new n;if(c.issues.length){const r=new(o?.Err??e)(c.issues.map(e=>u(e,i,a())));throw Error.captureStackTrace(r,o?.callee),r}return c.value})(l),m=/* @__PURE__*/(e=>async(r,t,s,n)=>{const o=s?Object.assign(s,{async:!0}):{async:!0};let i=r._zod.run({value:t,issues:[]},o);if(i instanceof Promise&&(i=await i),i.issues.length){const r=new(n?.Err??e)(i.issues.map(e=>u(e,o,a())));throw Error.captureStackTrace(r,n?.callee),r}return i.value})(l);function y(e,r){const s={};for(;e.length;){const n=e[0],{code:o,message:a,path:i}=n,c=i.join(".");if(!s[c])if("unionErrors"in n){const e=n.unionErrors[0].errors[0];s[c]={message:e.message,type:e.code}}else s[c]={message:a,type:o};if("unionErrors"in n&&n.unionErrors.forEach(r=>r.errors.forEach(r=>e.push(r))),r){const e=s[c].types,a=e&&e[n.code];s[c]=t(c,r,s,o,a?[].concat(a,n.message):n.message)}e.shift()}return s}function h(e,r){const s={};for(;e.length;){const n=e[0],{code:o,message:a,path:i}=n,c=i.join(".");if(!s[c])if("invalid_union"===n.code){const e=n.errors[0][0];s[c]={message:e.message,type:e.code}}else s[c]={message:a,type:o};if("invalid_union"===n.code&&n.errors.forEach(r=>r.forEach(r=>e.push(r))),r){const e=s[c].types,a=e&&e[n.code];s[c]=t(c,r,s,o,a?[].concat(a,n.message):n.message)}e.shift()}return s}function g(t,s,n={}){if((e=>"_def"in e&&"object"==typeof e._def&&"typeName"in e._def)(t))return async(o,a,i)=>{try{const r=await t["sync"===n.mode?"parse":"parseAsync"](o,s);return i.shouldUseNativeValidation&&e({},i),{errors:{},values:n.raw?Object.assign({},o):r}}catch(e){if((e=>Array.isArray(null==e?void 0:e.issues))(e))return{values:{},errors:r(y(e.errors,!i.shouldUseNativeValidation&&"all"===i.criteriaMode),i)};throw e}};if((e=>"_zod"in e&&"object"==typeof e._zod)(t))return async(o,a,i)=>{try{const r="sync"===n.mode?p:m,a=await r(t,o,s);return i.shouldUseNativeValidation&&e({},i),{errors:{},values:n.raw?Object.assign({},o):a}}catch(e){if((e=>e instanceof f)(e))return{values:{},errors:r(h(e.issues,!i.shouldUseNativeValidation&&"all"===i.criteriaMode),i)};throw e}};throw new Error("Invalid input: not a Zod schema")}export{g as zodResolver};
//# sourceMappingURL=zod.modern.mjs.map
